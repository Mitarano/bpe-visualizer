<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Byte Pair Encoding Visualizer – Einfach & Interaktiv</title>
  <style>
    :root{ color-scheme: light dark; }

    /* Dark mode (default if user prefers dark) */
    @media (prefers-color-scheme: dark){
      :root{
        --bg: #0b0f14;
        --panel: #111720;
        --panel-sub: #0f1623;
        --muted: #93a1b1;
        --text: #e6edf3;
        --accent: #7aa2ff;
        --accent-2: #67e8f9;
        --good: #22c55e;
        --warn: #f59e0b;
        --danger: #ef4444;
        --chip: #182130;
        --chip-border: #2a364a;
        --border: #1d2635;
        --btn-bg: #1a2231;
        --btn-fg: #e6edf3;
        --btn-primary-fg: #0b1020;
      }
    }

    /* Light mode */
    @media (prefers-color-scheme: light){
      :root{
        --bg: #f7fafc;
        --panel: #ffffff;
        --panel-sub: #f3f4f6;
        --muted: #4b5563;
        --text: #111827;
        --accent: #2563eb;
        --accent-2: #06b6d4;
        --good: #16a34a;
        --warn: #d97706;
        --danger: #dc2626;
        --chip: #f3f4f6;
        --chip-border: #e5e7eb;
        --border: #e5e7eb;
        --btn-bg: #e5e7eb;
        --btn-fg: #111827;
        --btn-primary-fg: #ffffff;
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color:var(--text);
      background: var(--bg); /* einfarbig, kein Verlauf */
    }
    .app{max-width:1200px;margin:24px auto;padding:0 16px 16px;}
    h1{font-size:clamp(22px, 4vw, 28px);font-weight:750;margin:0 0 12px 0;letter-spacing:0.2px}
    p.lead{color:var(--muted);margin:0 0 18px 0}

    .grid{display:grid;grid-template-columns:1.1fr 0.9fr;gap:16px}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}

    .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.12)}
    .card .hd{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px}
    .card .bd{padding:14px}

    textarea{
      width:100%;min-height:104px;resize:vertical;border-radius:10px;border:1px solid var(--border);
      background:var(--panel-sub);color:var(--text);padding:10px 12px;font-size:14px;line-height:1.4;
    }

    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .row .grow{flex:1}

    .btn{appearance:none;border:1px solid var(--chip-border);background:var(--btn-bg);color:var(--btn-fg);padding:9px 12px;border-radius:10px;cursor:default;font-weight:600;font-size:13px;transition:.15s transform ease, .15s background ease; box-shadow:0 6px 16px rgba(0,0,0,.08)}
    .btn:hover{transform:translateY(-1px)}
    .btn:active{transform:translateY(0)}
    .btn.primary{border-color:transparent;background:var(--accent);color:var(--btn-primary-fg)}

    .tokens{display:flex;flex-direction:column;gap:8px;max-height:365px;overflow:auto;padding:12px;scroll-padding:12px}
    .line{display:flex;flex-wrap:wrap;gap:6px;align-items:center}

    .tok{display:inline-flex;align-items:center;justify-content:center;min-width:24px;padding:7px 8px;border-radius:10px;border:1px solid var(--chip-border);background:var(--chip);position:relative;font-weight:650;letter-spacing:.2px;transition:.15s}
    .tok.char{opacity:.95}
    .tok .dot{position:absolute;top:-5px;right:-5px;width:9px;height:9px;border-radius:50%;background:var(--accent);box-shadow:0 0 0 2px rgba(0,0,0,.25)}
    .tok.space{opacity:.9;border-style:dashed}
    .tok.highlight{outline:2px solid var(--accent);box-shadow:0 0 0 3px rgba(122,162,255,.18)}
    .tok.merge-flash{animation:flash .6s ease}

    @keyframes flash{0%{box-shadow:0 0 0 0 rgba(122,162,255,.0)}30%{box-shadow:0 0 0 8px rgba(122,162,255,.2)}100%{box-shadow:0 0 0 0 rgba(122,162,255,.0)}}

    .pairs{max-height:365px;overflow:auto;padding-right:6px}
    .pair-row{display:grid;grid-template-columns:1fr auto 72px;gap:10px;align-items:center;padding:6px 8px;border-radius:10px;border:1px solid var(--border);margin-bottom:8px;background:var(--panel-sub);cursor:default}
    .pair-row.active{border-color:var(--accent);box-shadow:0 0 0 3px rgba(122,162,255,.18)}
    .bar{height:8px;background:#1f2a3e;border-radius:6px;overflow:hidden}
    .bar>i{display:block;height:100%;background:linear-gradient(90deg,var(--accent), var(--accent-2))}

    .vocab{display:flex;flex-wrap:wrap;gap:6px;max-height:152px;overflow:auto}
    .chip{border:1px solid var(--chip-border);background:var(--chip);border-radius:999px;padding:6px 10px;font-weight:600;display:inline-flex;gap:8px;align-items:center}
    .chip.muted{opacity:.55;border-style:dashed}

    .history{max-height:152px;overflow:auto}
    .history .hrow{display:flex;align-items:center;gap:10px;padding:6px 8px;border:1px dashed var(--border);border-radius:10px;margin-bottom:6px}
    .hrow .id{font-weight:800;opacity:.8}

    .mini{font-size:12px;color:var(--muted)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;padding:2px 6px;border:1px solid var(--chip-border);border-radius:6px;background:var(--panel-sub)}
    .wfull{width:100%}
    .split{display:flex;gap:8px;width:100%}
    .split .btn{flex:1}
    .pair-key.chips{display:flex;gap:6px;align-items:center;flex-wrap:wrap;font-family:inherit}
  </style>
</head>
<body>
  <div class="app">
    <h1>Byte Pair Encoding Visualizer</h1>
    <p class="lead">Gib einen Text ein. Die initialen Tokens sind Zeichen. Bei jedem Schritt wird das häufigste Paar benachbarter Tokens zusammengeführt.</p>

    <div class="card" style="margin-bottom:16px">
      <div class="hd"><strong>1) Eingabe & Steuerung</strong></div>
      <div class="bd">
        <div class="row" style="margin-bottom:8px">
          <div class="grow">
            <textarea id="inputText" placeholder="Die Katze sitzt auf der Matte und schnurrt leise, während der Hund daneben schläft."></textarea>
          </div>
          <div style="display:flex;flex-direction:column;gap:8px;min-width:230px">
            <button class="btn primary wfull" id="btnInit">Neu starten</button>
            <div class="split">
              <button class="btn" id="btnBack">◀︎ Zurück</button>
              <button class="btn" id="btnForward">Weiter ▶︎</button>
            </div>
          </div>
        </div>
        <div class="row" style="justify-content:space-between">
          <div class="mini">Hinweis: Leerzeichen werden immer als <span class="kbd">␣</span> dargestellt.</div>
          <label class="switch"><input type="checkbox" id="toggleTopOnly" checked><span>Nur Top-30 Paare zeigen</span></label>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="hd"><strong>2) Aktueller Token-Stream</strong><span class="hint" id="stepInfo" style="margin-left:auto"></span></div>
        <div class="bd"><div id="tokens" class="tokens"></div></div>
      </div>

      <div class="card">
        <div class="hd"><strong>3) Häufigkeiten benachbarter Token</strong></div>
        <div class="bd">
          <div id="pairs" class="pairs"></div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:16px">
      <div class="card">
        <div class="hd"><strong>4) Vokabular</strong></div>
        <div class="bd"><div id="vocab" class="vocab"></div></div>
      </div>
      <div class="card">
        <div class="hd"><strong>5) Merge-Verlauf</strong><span class="mini" style="margin-left:auto">klicke, um zum jeweiligen Schritt zu springen</span></div>
        <div class="bd"><div id="history" class="history"></div></div>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="hd"><strong>Wie funktioniert BPE?</strong></div>
      <div class="bd">
        <ol>
          <li>Starte mit einzelnen Zeichen als Token.</li>
          <li>Zähle alle benachbarten Token-Paare im Text.</li>
          <li>Merge das <em>häufigste</em> Paar zu einem neuen Token (z. B. <span class="kbd">t</span> + <span class="kbd">h</span> → <span class="kbd">th</span>).</li>
          <li>Wiederhole 2–3, bis genug Merges durchgeführt wurden. Das Vokabular wächst um die neuen Token.</li>
        </ol>
      </div>
    </div>
    <p class="mini" style="margin:8px 4px 0 4px;">Hinweis: Dieses Tool demonstriert klassisches, zeichenbasiertes BPE pro Iteration (jeweils das häufigste adjazente Paar wird gemergt). Es ist eine didaktische Visualisierung und bildet bewusst nicht alle Details moderner Tokenizer nach.</p>
  </div>

  <script>
  // --- Utility helpers ------------------------------------------------------
  const SPACE_VIS = "␣"; // Visual symbol for space
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // escape HTML special chars safely BEFORE using in innerHTML
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, c=>({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'
    })[c]);
  }
  // convert spaces to ␣ then escape for HTML
  function displayText(t){ return String(t).replace(/ /g, SPACE_VIS); }
  function safeHTMLText(t){ return escapeHtml(displayText(t)); }

  // Token object: { text:string, depth:number, birth:number }
  function charTokensFromLine(line){
    const arr = [];
    for(const ch of [...line]) arr.push({ text: ch, depth: 0, birth: 0 });
    return arr;
  }
  function tokensFromText(text){
    const lines = text.replace(/\r\n?/g, "\n").split("\n");
    return lines.map(charTokensFromLine);
  }

  function pairKey(a,b){ return a.text + "\u241F" + b.text; }
  function keyToPair(key){ const [a,b] = key.split("\u241F"); return [a,b]; }

  function countPairs(lines){
    const map = new Map();
    for(const line of lines){
      for(let i=0;i<line.length-1;i++){
        const k = pairKey(line[i], line[i+1]);
        map.set(k, (map.get(k)||0)+1);
      }
    }
    return map;
  }

  function chooseTopPair(map){
    let bestKey = null, bestCount = 0;
    for(const [k,c] of map){
      if(c>bestCount){ bestKey=k; bestCount=c; }
      else if(c===bestCount && bestKey && k<bestKey){ bestKey = k; }
    }
    return bestKey ? { key: bestKey, count: bestCount } : null;
  }

  function mergeOnce(lines, aText, bText, birthStep=0){
    const out = [];
    let mergedOccurrences = 0;
    for(const line of lines){
      const next = [];
      let i=0;
      while(i<line.length){
        const cur=line[i], nxt=line[i+1];
        if(nxt && cur.text===aText && nxt.text===bText){
          next.push({ text: cur.text + nxt.text, depth: Math.max(cur.depth, nxt.depth)+1, birth: birthStep });
          i+=2; mergedOccurrences++;
        } else { next.push(cur); i+=1; }
      }
      out.push(next);
    }
    return { lines: out, mergedOccurrences };
  }

  // Vokabular: eindeutige Token, sortiert nach frühester Geburts-Iteration, dann alphabetisch
  function buildVocab(lines){
    const seen = new Map(); // text -> earliest birth
    for(const line of lines){
      for(const t of line){
        const tb = (t.birth ?? 0);
        const prev = seen.get(t.text);
        if(prev===undefined || tb < prev) seen.set(t.text, tb);
        for(const ch of [...t.text]){ if(!seen.has(ch)) seen.set(ch, 0); }
      }
    }
    const arr = [...seen.entries()].map(([text,birth])=>({ text, birth }));
    arr.sort((a,b)=> (a.birth-b.birth) || a.text.localeCompare(b.text));
    return arr;
  }

  // Vollständiges Vokabular über alle bisherigen Merges hinweg (persistentes Vokabular)
  function buildVocabAll(state){
    const map = new Map(); // text -> birth
    // Basis: alle Zeichen aus der Initialeingabe (birth=0)
    for(const line of state.initialLines){
      for(const t of line){ if(!map.has(t.text)) map.set(t.text, 0); }
    }
    // Aus Merges: neuer Token a+b mit birth = Merge-Index+1
    for(let i=0;i<state.merges.length;i++){
      const [a,b] = keyToPair(state.merges[i].key);
      const tok = a + b;
      if(!map.has(tok)) map.set(tok, i+1);
    }
    // Markiere aktuell genutzte Tokens
    const inUse = new Set();
    for(const line of state.lines){ for(const t of line){ inUse.add(t.text); } }
    const arr = [...map.entries()].map(([text,birth])=>({ text, birth, inUse: inUse.has(text) }));
    arr.sort((a,b)=> (a.birth-b.birth) || a.text.localeCompare(b.text));
    return arr;
  }

  function tokenCount(lines){ let n=0; for(const line of lines) n+=line.length; return n; }

  // Kann noch gemerged werden? (Top-Paar muss Häufigkeit > 1 haben)
  function canMergeMore(lines){
    const top = chooseTopPair(countPairs(lines));
    return !!(top && top.count > 1);
  }

  // --- Rendering ------------------------------------------------------------
  const elTokens = document.getElementById('tokens');
  const elPairs  = document.getElementById('pairs');
  const elVocab  = document.getElementById('vocab');
  const elHist   = document.getElementById('history');
  const elStepInfo = document.getElementById('stepInfo');
  const toggleTopOnly = document.getElementById('toggleTopOnly');

  function renderTokens(state, highlightPairKey=null){
    elTokens.innerHTML='';
    const [hA,hB] = highlightPairKey ? keyToPair(highlightPairKey) : [null,null];

    state.lines.forEach(line=>{
      const lineEl = document.createElement('div');
      lineEl.className='line';
      line.forEach((tok,i)=>{
        const div = document.createElement('div');
        div.className = 'tok ' + (tok.text===' ' ? ' space':'');
        div.textContent = displayText(tok.text);
        div.dataset.birth = tok.birth;
        if(tok.depth>0 && tok.birth===state.merges.length){ const dot=document.createElement('i'); dot.className='dot'; div.appendChild(dot); }
        if(hA!==null && line[i+1] && tok.text===hA && line[i+1].text===hB) div.classList.add('highlight');
        if(hA!==null && line[i-1] && line[i-1].text===hA && tok.text===hB) div.classList.add('highlight');
        lineEl.appendChild(div);
      });
      elTokens.appendChild(lineEl);
    });

    elStepInfo.textContent = `Schritt: ${state.merges.length} · Token gesamt: ${tokenCount(state.lines)}`;
  }

  function renderPairs(state){
    elPairs.innerHTML='';
    const map = countPairs(state.lines);
    state.pairsMap = map;

    const arr = [...map.entries()].map(([key,count])=>({ key, count }))
                 .sort((a,b)=> b.count-a.count || a.key.localeCompare(b.key));
    const top = chooseTopPair(map);
    // Markiere kein Paar, wenn alle Häufigkeiten == 1
    state.topPairKey = (top && top.count > 1) ? top.key : null;

    const max = arr[0]?.count || 1;
    const list = toggleTopOnly.checked ? arr.slice(0,30) : arr;

    list.forEach(p=>{
      const row = document.createElement('div');
      row.className = 'pair-row' + (state.topPairKey===p.key ? ' active' : '');
      row.dataset.key = p.key;
      const [a,b] = keyToPair(p.key);
      row.innerHTML = `
        <div class="pair-key chips"><span class="chip">${safeHTMLText(a)}</span><span class="chip">${safeHTMLText(b)}</span></div>
        <div class="bar"><i style="width:${Math.max(8,(p.count/max)*100)}%"></i></div>
        <div style="text-align:right;font-weight:800">${p.count}</div>`;
      elPairs.appendChild(row);
    });

    // Top-Paar im Token-Stream hervorheben
    renderTokens(state, state.topPairKey);
    // Weiter-Button aktivieren/deaktivieren
    updateForwardButton();
  }

  function renderVocab(state){
    elVocab.innerHTML='';
    buildVocabAll(state).forEach(v=>{
      const chip = document.createElement('div');
      chip.className='chip' + (v.inUse ? '' : ' muted');
      chip.textContent = displayText(v.text);
      elVocab.appendChild(chip);
    });
  }

  function renderHistory(state){
    elHist.innerHTML='';
    state.merges.forEach((m,i)=>{
      const row = document.createElement('div');
      row.className='hrow';
      const [a,b] = keyToPair(m.key);
      row.innerHTML = `<span class="id">${i+1}.</span>
        <span class="pair-key chips"><span class="chip">${safeHTMLText(a)}</span><span class="chip">${safeHTMLText(b)}</span></span>`;
      row.style.cursor='pointer';
      row.addEventListener('click', ()=> jumpToStep(i+1));
      elHist.appendChild(row);
    });
  }

  function flashNewTokens(){
    const step = state.merges.length;
    const nodes = document.querySelectorAll('.tok.merged[data-birth="'+step+'"]');
    nodes.forEach(n=> n.classList.add('merge-flash'));
    setTimeout(()=> nodes.forEach(n=> n.classList.remove('merge-flash')), 650);
  }

  // --- State & Actions ------------------------------------------------------
  const state = {
    initialLines: [],
    lines: [],
    merges: [], // { key, count }
    selectedPairKey: null,
    topPairKey: null,
    pairsMap: new Map(),
  };

  function resetToChars(){
    const text = (document.getElementById('inputText').value || '').trimEnd();
    state.initialLines = tokensFromText(text);
    state.lines = deepClone(state.initialLines);
    state.merges = [];
    state.selectedPairKey = null;
    renderPairs(state); renderTokens(state, state.topPairKey); renderVocab(state); renderHistory(state);
  }

  function stepMerge(){
    const map = countPairs(state.lines);
    const top = chooseTopPair(map);
    if(!top || top.count <= 1){ alert('Keine weiteren Merges möglich (häufigstes Paar hat Häufigkeit ≤ 1).'); return; }
    const [a,b] = keyToPair(top.key);

    const birthStep = state.merges.length + 1;
    const { lines:newLines, mergedOccurrences } = mergeOnce(state.lines, a, b, birthStep);
    if(mergedOccurrences===0){ alert('Top-Paar kommt nicht mehr vor.'); return; }

    state.lines = newLines;
    state.merges.push({ key: top.key, count: top.count });

    renderPairs(state); renderTokens(state, state.topPairKey); renderVocab(state); renderHistory(state);
    flashNewTokens();
  }

  function jumpToStep(k){
    let lines = deepClone(state.initialLines);
    for(let i=0;i<k;i++){
      const [a,b] = keyToPair(state.merges[i].key);
      lines = mergeOnce(lines, a, b, i+1).lines;
    }
    state.lines = lines;
    state.selectedPairKey = null;
    renderPairs(state); renderTokens(state, state.topPairKey); renderVocab(state);
  }

  // --- Wire UI --------------------------------------------------------------
  document.getElementById('btnInit').addEventListener('click', ()=>{ resetToChars(); updateForwardButton(); });
  document.getElementById('btnBack').addEventListener('click', ()=>{
    if(state.merges.length===0) return;
    state.merges.pop();
    let lines = deepClone(state.initialLines);
    state.merges.forEach((m, idx)=>{ const [a,b] = keyToPair(m.key); lines = mergeOnce(lines, a, b, idx+1).lines; });
    state.lines = lines; state.selectedPairKey=null;
    renderPairs(state); renderTokens(state, state.topPairKey); renderVocab(state); renderHistory(state);
    updateForwardButton();
  });
  document.getElementById('btnForward').addEventListener('click', ()=> stepMerge());
  toggleTopOnly.addEventListener('change', ()=> renderPairs(state));

  function updateForwardButton(){
    const map = countPairs(state.lines);
    const top = chooseTopPair(map);
    const btn = document.getElementById('btnForward');
    if(!top || top.count <= 1){ btn.disabled = true; btn.title = 'Keine weiteren Merges (Top ≤ 1)'; }
    else { btn.disabled = false; btn.title = ''; }
  }

  // --- Init with example ----------------------------------------------------
  document.getElementById('inputText').value = 'Die Katze sitzt auf der Matte und schnurrt leise, während der Hund daneben schläft.';
  resetToChars();
  updateForwardButton();
  </script>
</body>
</html>
